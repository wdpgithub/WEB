常量/字面量   确定的值叫做常量
100     3,13
[注]JS中数据类型分为两大类
1.基本数据类型
<1>数字		number
<2>字符串	string	   所有带双引号/单引号
<3>布尔值	boolean    true   false
<4>特殊数据类型 null空     underfind未声明

2.复合数据类型
<1>数组		array
<2>对象		object

[注]变量,值可以改变的叫做变量
1.声明变量	通过关键字(系统定义的有特殊功能的单词)var
	<1>声明变量的时候,同时给变量赋值,叫做初始化.
2.变量赋值
3.可以同时定义多个变量    变量之间要使用逗号隔开


标识符:用户自定义的所有名字叫做标识符.变量名
规律:
1.标识符必须由数字、字母、下划线和美元符号$组成
2.不能以数字开头
3.标识符区分大小写,age和Age这是两个变量
4.标识符必须见名思意.

输入当前变量/常量的数据类型
[格式] typeof 变量/常量
[注]JS是弱语言,变量被赋值成什么类型就是什么类型.不要在后续的代码里改变该变量的数据类型,很容易引起代码歧义.

运算符
算数运算符	+ - / *
关系运算符	
逻辑运算符	与&&    或||     非!
自动数据类型转换
1.任何类型的数据和字符串类型数据做相加操作的时候,其他数据类型 会自动转换成为字符串类型.字符串拼接.此时的相加操作不再是数字意义加法,而是表示拼接的意思.
如果其中一个操作数是字符串的时候,+号叫做字符串拼接符.
2.任何数据除了和字符串做相加运算外,
	<1>与NaN做算数运算的结果始终都是NaN,包括NaN本身和NaN做运算结果也为NaN.
	<2>字符串如果是纯数字字符串转成数字,否则转换成NaN
总结:任何其他数据类型除了和字符串做相加操作外,与数字类型做算数运算的时候,其他数据类型都会自动转换成数字
布尔值:	true => 1	false => 0
特殊数据类型中:null => 0	undefined => NaN
强制数据类型转成布尔值
	通过方法Boolean()进行强制数据类型转换
	[作用]将别的数据类型强制转换成布尔值
结论:
	1.数字0转换布尔值为false,所有非0的数字转成布尔值都为true.
	2.空字符串转换布尔值为false,所有非空字符串转成布尔值都为true.
	3.null和undefined转成布尔值都是false.
强制数据类型转成数字
number()	将别的数据类型转成数字
	1.布尔值 true => 1	false => 0
	2.字符串 纯数字的字符串 =>对应的数字,否则NaN
	3,特殊数据类型 null => 0   undefined => NaN

	parseInt()	兼容Number的功能, 取整
	parseFloat()	取浮点数  带小数的数字     可以将别的数据类型转换成数字类型

补充    var a=1/0    alert(a);Infinty    无穷大  var a=-1/0    alert(a);-Infinty    无穷小
一元运算符:只能操作一个值的运算符.
a++;
	表达式值:++后置,先取a的值,然后在进行+1操作

++a;
	表达式值:++前置,先进行+1操作,然后取a的值操作
a--;--a;同上;
[注]关系运算符中操作数为非数字的时候要遵从以下规律:
1.如果两个操作数都是数值,则数值比较
2.两个操作都是字符串,则比两个字符串对应的字符串编码值
ASCII码表值
	逐位进行比较,直到比较大小,终止比较
3.两个操作数有一个是数值,则将另一个转换成数值,再进行数值比较

字符   存储在计算机   以二进制方式进行存储
ASCII码表    二进制码和字符对应密码表

关系运算符:
在不等和等于的比较上,如果操作数为非数值,则遵从以下规律:
1.一个操作数为布尔值,则比较之前将其转换成数值,false转成0, true转成1;
2.一个操作数为字符串,则比较之前将其转换成数值再进行比较
3.一个操作数为NaN,则==返回false,!=返回true,并且NaN和NaN自身不等
4.在全等(===)和全不等(!===),如果值和类型都相等,才返回true,否则返回false

逻辑运算符
与 	&&
表达式1 && 表达式2
[注]只有当两个表达式的的结果都为真的时候,与运算的结果才为true.
[短路操作]当第一个表达式1为false的时候,第二个表达式2就不会执行,直接判断整个与运算为false.
或	||
表达式1 || 表达式2
[注]只有当两个表达式的结果都为假的时候,或运算的结果,才为false.
[短路操作]当表达式1为true的时候,表达式2就不会执行,判断整个表达式为true.

逻辑非运算遵从下述规律:
1.如果操作数是一个空字符串,返回true
2.操作数是非字符串,返回false
3.操作数是0,返回true
4.操作数任意非0的数值(Infinity),false
5.操作数为NaNcy,返回true
6.操作数undefined,返回true

进制转换
十进制转二进制
[方法]除二取余 ,倒序排列
十进制数转二进制
52 =>110100

1*2^2+1*2^4+1*2^5=52

十进制转十六进制/八进制
[方法]先将十进制数转成二进制,再将二进制转成对应的八进制或者十六进制

二进制转八进制
[方法]从右向左,每三位一组,不足三位的使用0补齐,将每一组数转成十进制

二进制转十六进制
[方法]从右向左,每四位一组,不足四位的使用0补齐,将每一组数转成十进制

程序的三大结构:
顺序结构

选择结构
单分支
[格式]
if(判断语句)
	执行语句;
[过程]先去判断括号中的判断条件,如果成立,回去执行紧跟着if语句的一条语句.否则就不会去执行紧跟着if语句的一条语句.
[注]if语句只能决定,紧跟着if语句后的一条语句是否执行.

[注]在JS中,我们把{}括起来的 所有语句都当做一条语句对待.
[注]执行语句,一定要比if判断条件缩进四个空格.

双分支
[格式]
if(判断条件/表达式){
	执行语句1
}else{
	执行语句2
}
[规则]当括号内的判断条件/表达式结果成立的时候,执行执行语句1,否则执行执行语句2;

多分支
[格式]
if(表达式1){
	执行语句1
}else if(表达式2){
	执行语句2
}else if(表达式3){
	执行语句3
}
……
else if(表达式n){
	执行语句n
}
[规律]从上往下,满足哪个条件就执行对应的语句,都不满足时,执行最后的else的语句,只能进入其中之一.

多分支语句
[格式]
switch(表达式){
   case 常量1：
	语句;	    
	break;
   case 常量2：
	语句;	    
	break;
   case 常量3：
	语句;	    
	break;
   default:
	如果上述语句不成立,执行这里
	break;
}
【规律】
表达式的结果等于哪个case的常量，则执行其后的语句，执行完break以后，就跳出switch结构，如果不满足，执行default语句。
[注]1.break是一定不能省略的,如果省略就会造成事件穿透.2.default一般情况下,不要省略,为了避免语句歧义.
[注意点]
1.if后面的()不能省略,()后面不要加分号 
2.if分支即便一句话也要把{}写上
3.if嵌套不要超过三层
4.switch语句把default分支一定要写上,防止在以后的维护中产生歧义
5.把执行概率更大(正常情况)放在前面(if,case)
6.if else和switch: if else一般表示两个分支或者嵌套比较少的分支,如果分支多的话,用switch。
[代码规范]
1.所有括号成对输入
2.所有的双引号成对输入
3.一句话站一行
4.缩进对齐
	<1>同级对齐 <2>子一级不上一级缩进四个空格
三目运算符/条件运算符
	[格式]
	表达式1  ?  表达式2   :表达式3;
[执行过程]先求解表达式1,若为非0(真),则求解表达式2,若表达式1为0(假),则求解表达式3。

循环结构
	while循环
	【格式】
	while（表达式）{
	循环语句；
}
【注】
1.先判断表达式，表达式成立执行循环语句
2.循环条件中使用的变量（循环变量）需要经过初始化
3.循环体中，应有结束循环的条件，否则会照成死循环
4.循环体中,可以写若干个合法的js代码,包括if,也可以在套一个循环

[格式]
do{
   循环语句;
}while(表达式);
[注]
1.最后的分号不要忘记
2.循环条件中使用的变量需要经过初始化
3.循环体中,应有结束循环的条件,否则会造成死循环.
while循环和do_whilede循环的区别
1.while循环是先判断表达式,然后再去执行循环语句.
2.do_while循环先去执行一次循环语句,然后再去判断一次表达式

for循环
[格式]
	for(表达式1;表达式2;表达式3){循环语句;}
[执行顺序]
1.先求解表达式1(只求一次)
2.求解表达式2,若其值为真(非0)则执行佛如语句中循环语句,然后再去求解表达式3;在求解表达式2,若为假,则结束循环.

break语句
1.在break语句中使流程跳出switch
2.在循环语句中流程跳出当前的循环

continue语句
[注]只能在循环语句中使用,使本次循环结束,即跳出循环体中下面未执行的语句,接着进行下次是否执行循环的判断

函数
函数的当它被调用时执行的可重复使用的代码块
函数的定义:
[注]无参函数的声明
[格式]
	function 函数名(){函数体;}
函数调用:函数名();

函数的分类:
1.内置函数(系统函数、官方函数）
alert（）  parseInt（） document.write（）
2.自定义函数
用户根据实际需求,自己封装一个函数

计算所有传入参数的和,具体传入多少参数不稳定
[注]arguments
[注]在每一个函数内,都有一个内置的数组,是一个变量,叫做arguments。arguments可以存储当前函数传入的所有参数，并且是通过传参的顺序排列的。
[注]argiments.length 输出传入参数的个数。
[注]访问arguments里面的数据,需要通过房间号/下标进行访问。


函数的返回值：return
[注]希望能够在函数外部获取到,函数调用的结果
[注]如果我们要是外部获取到函数内运行的结果,可以通过return语句跟后面的要返回的值来实现返回值。简单说就是return后面所跟表达式的值，就是当前函数调用的值
[注]函数执行到return语句以后,就执行结束,跟在return后面其他的语句执行不到了

作用域:就是起作用的范围,或者是有效范围。每一个函数的声明都会形成一个作用域
1.全局作用域
	全局作用域声明的变量	全局变量
2.局部作用域
	局部声明的变量		局部变量，局部变量的声明周期和生效范围，都是声明该变量的函数区域，当函数调用完成以后，直接销毁。

如果全局作用域和局部作用域变量重名，我们采取就近原则，当前访问这个变量离哪个作用域近，就是哪个作用域。


/*
1.面试官问你递归的相关知识，面试官水平不错
2.工作中,一般情况下禁止使用递归
*/

函数的递归

递归的概念：
	函数可以自己调用自己,称为递归调用
[注]我们可以写出递归,但是我们并不知道它是如何得出结果


函数的递归调用
方法:
	1.首先.去找临界值,则不需计算,获得的值
	2.找你这一次和上一次的关系
	3.假设当前函数已经可以使用了,调用自身计算上一次的运算结果,再写出这次的运算结果
[特点]
	1.必须有参数
	2.必须有return

1加到n的和		sum(100)=sum(99)+100
			sum(n)=sum(n-1)+n

[注]递归会在短时间内,使内存剧增.	

事件驱动函数:在和页面交互的过程中调用的函数

事件:和页面交互的行为
鼠标浮动或离开到某个区域时(onmouseover、onmouseout）、文本框获取焦点和失去焦点时（onfocus、onblur)等；
